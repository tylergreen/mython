#! /usr/bin/env python
# ______________________________________________________________________
"""Module nfa

Defines a set of utility functions for working with and composing the NFA
data structures generated by pgen and PyPgen.

Jonathan Riehl
"""
# ______________________________________________________________________
# Module imports

# ______________________________________________________________________
# Function definitions

def rewrite_arcs (label_map, nfa):
    """Rewrite the label arcs in a NFA according to the input remapping."""
    states = [[(label_map[label], tostate) for (label, tostate) in arcs]
              for arcs in nfa[2]]
    return (nfa[0], nfa[1], states, nfa[3], nfa[4])

# ______________________________________________________________________

def nfa_union (nfa0, nfa1):
    "Constructs the union  of two NFA's."
    states = nfa0[2][:]
    offset = len(states)
    states.extend([[(label, tostate + offset) for (label, tostate) in arcs]
                   for arcs in nfa1[2]])
    states.append([(0, nfa0[3]), (0, nfa1[3] + offset)])
    states.append([])
    end_state_index = len(states) - 1
    end_state_arc = (0, end_state_index)
    states[nfa0[4]].append(end_state_arc)
    states[nfa1[4] + offset].append(end_state_arc[:])
    return (nfa0[0], nfa0[1], states, len(states) - 2, len(states) - 1)

# ______________________________________________________________________

def compose_nfas (nfas0, nfas1):
    """Compose two NFA tuples generated by pgen.

    Accepts two NFA set tuples, NFAS0 and NFAS1, and composes them as follows:

    1. Creates a new label table starting with NFAS0's label table,
       then adding labels from NFAS1.  Also builds a map from label
       indices from the old.
    2. Reconstructs NFAS1 by mapping each arc to the new label table.
    3. Merges NFA's on a name by name basis.
    4. Returns a new NFA set.
    """
    nfas0_nfas, nfas0_labels = nfas0
    nfas1_nfas, nfas1_labels = nfas1
    # ____________________________________________________________
    # Part 1.
    nfas2_labels = nfas0_labels[:]
    label_map_1_to_2 = {}
    index = 0
    for label_tup in nfas1_labels:
        if label_tup in nfas2_labels:
            label_map_1_to_2[index] = nfas2_labels.index(label_tup)
        else:
            label_map_1_to_2[index] = len(nfas2_labels)
            nfas2_labels.append(label_tup)
        index += 1
    # ____________________________________________________________
    # Part 2.
    nfas2_nfas = [rewrite_arcs(label_map_1_to_2, nfa) for nfa in nfas1_nfas]
    nfas2_nfa_map = {}
    index = 0
    for nfa in nfas2_nfas:
        nfas2_nfa_map[nfa[1]] = index
        index += 1
    # ____________________________________________________________
    # Part 3.
    new_nfa_type = max((nfa_ty for (nfa_ty, _, _, _, _) in nfas2_nfas)) + 1
    for nfa in nfas0_nfas:
        nfa_name = nfa[1]
        if nfa_name in nfas2_nfa_map:
            nfas2_nfa_index = nfas2_nfa_map[nfa_name]
            nfas2_nfas[nfas2_nfa_index] = nfa_union(
                nfas2_nfas[nfas2_nfa_index], nfa)
        else:
            nfas2_nfas.append((new_nfa_type, nfa[1], nfa[2], nfa[3], nfa[4]))
            new_nfa_type += 1
    # ____________________________________________________________
    # Part 4.
    return (nfas2_nfas, nfas2_labels)

# ______________________________________________________________________

def nfa_to_dot (nfa, label_table = None, state_prefix = None):
    """Given a NFA tuple, output a string with Graphviz DOT code."""
    if state_prefix is None:
        state_prefix = "s"
    ret_val = []
    state_index = 0
    for state in nfa[2]:
        state_name = "%s%d" % (state_prefix, state_index)
        state_attrs = {}
        if state_index == nfa[3]:
            state_attrs["peripheries"] = 2
        if state_index == nfa[4]:
            state_attrs["peripheries"] = 2
            state_attrs["style"] = "filled"
        state_attrs_str = ""
        if state_attrs:
            state_attrs_str = (" [%s]" %
                               (", ".join(["%s = %s" % (str(k), str(v))
                                           for (k, v) in state_attrs.items()])
                                ))
        ret_val.append("%s%s;" % (state_name, state_attrs_str))
        for (label, tostate) in state:
            arc_attrs = {}
            if label_table:
                arc_attrs["label"] = label_table[label][1]
            else:
                arc_attrs["label"] = str(label)
            arc_attrs_str = ""
            if arc_attrs:
                arc_attrs_str = " [%s]" % (
                    ", ".join(["%s = %s" % (str(k), str(v))
                               for (k, v) in arc_attrs.items()]))
            ret_val.append("%s -> %s%d%s;" % (state_name, state_prefix,
                                              tostate, arc_attrs_str))
        state_index += 1
    return "\n".join(ret_val)

# ______________________________________________________________________

def find_nfa (nfas_tup, nfa_name):
    filtered_nfas = [nfa for nfa in nfas_tup[0] if nfa[1] == nfa_name]
    return filtered_nfas[0] if filtered_nfas else None

# ______________________________________________________________________
# Main routine

def main (*args):
    """Main routine for the basil.parsing.nfa module.

    Composes one or more grammars (represented as a collections of
    pgen non-deterministic finite state automata, or NFA's) into a single
    NFA.  By default, main() pretty-prints the resulting NFA to stdout.

    Flags:
    -n <symbol>    Output a Graphviz DOT file for the NFA that recognizes the
                   given symbol (can specify more than one).
    -o <filename>  Output the pretty-printed NFA collection to the given file.
    -q             Quiet. Suppress output of the resulting NFA.  Overrides -o.

    Non-flag arguments should be the file names of a pgen input files
    that will be composed into a single NFA collection.
    """
    import getopt
    import pprint
    from basil.parsing import PgenParser, PyPgen
    nfas_to_output = []
    output_file = None
    quiet = False
    opts, args = getopt.getopt(args, "n:o:q")
    for (opt_flag, opt_arg) in opts:
        if opt_flag == "-q":
            quiet = True
        elif opt_flag == "-o":
            output_file = opt_arg
        elif opt_flag == "-n":
            nfas_to_output.append(opt_arg)
    if len(args) < 1:
        print "Usage: nfa.py [flags] <pgenfile1> [<pgenfile2> ...]"
        return
    index = 0
    nfas_tups = []
    out_nfas = [[],[]]
    for arg in args:
        grammar_st = PgenParser.parseFile(arg)
        crnt_nfas = PyPgen.PyPgen().handleStart(grammar_st)
        nfas_tups.append((crnt_nfas, "g%d_" % index))
        out_nfas = compose_nfas(out_nfas, crnt_nfas)
        index += 1
    nfas_tups.append((out_nfas, "res"))
    if not quiet:
        out_nfas_str = pprint.pformat(out_nfas)
        if output_file:
            open(output_file, "w").write(out_nfas_str)
        else:
            print(out_nfas_str)
    if nfas_to_output:
        for nfa_name in nfas_to_output:
            nfas = [(find_nfa(nfas, nfa_name), nfas, nfas_pre)
                    for nfas, nfas_pre in nfas_tups]
            nfas_code = ["" if nfa is None else
                         nfa_to_dot(nfa, nfas[1], nfas_pre)
                         for (nfa, nfas, nfas_pre) in nfas]
            dotfile = open(nfa_name + ".dot", "w")
            dotfile.write("digraph G {\n%s}\n" % ("\n".join(nfas_code)))
            dotfile.close()

# ______________________________________________________________________    

if __name__ == "__main__":
    import sys
    main(*(sys.argv[1:]))

# ______________________________________________________________________
# End of nfa.py
