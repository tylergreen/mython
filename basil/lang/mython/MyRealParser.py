#! /usr/bin/env python
# ______________________________________________________________________
"""MyRealParser.py

Specializes the myfront parser generated by pgen2LL1 for evil!

Jonathan Riehl

$Id$
"""
# ______________________________________________________________________
# Module imports

from tokenize import *
from LL1Parser import parser_main
from myparser import MyParser
from basil.lang.mython.MyFrontExceptions import MyFrontSyntaxError

# ______________________________________________________________________
# Module data

__DEBUG__ = False

QUOTED = N_TOKENS
tok_name[QUOTED] = "QUOTED"
N_TOKENS += 1

TEST_FIRST_SET = ['~', 'not', '-', NUMBER, '{', '(', 'lambda', STRING, '[',
                  '`', '+', NAME]

# ______________________________________________________________________
# Class Definition

class MyRealParser (MyParser):
    """Class MyRealParser
    """
    # ____________________________________________________________
    def __init__ (self, *args, **kws):
        super(MyRealParser, self).__init__(*args, **kws)
        self.tok_names = tok_name

    # ____________________________________________________________
    def __call__ (self, *args, **kws):
        try:
            return super(MyRealParser, self).__call__(*args, **kws)
        except SyntaxError, syntax_err:
            raise MyFrontSyntaxError(syntax_err, self.line_offset + 1)

    # ____________________________________________________________
    def tokenize (self):
        """MyRealParser.tokenize()
        """
        ret_val = self.tokenizer.next()
        if __DEBUG__:
            print ret_val
        while ret_val[0] in (COMMENT, NL):
            if __DEBUG__:
                print "Skipping..."
            ret_val = self.tokenizer.next()
            if __DEBUG__:
                print ret_val
        return ret_val

    # ____________________________________________________________
    def pushpop (self, data):
        """MyRealParser.pushpop()
        """
        self.stack[-1][1].append((data, []))

    # ____________________________________________________________
    def parse_arglist (self):
        """Fixes conflict in automatically generated method."""
        self.push('arglist')
        while self.test_lookahead('~', NAME, 'not', '-', NUMBER, '{', '(',
                                  'lambda', '[', '`', '+', STRING):
            self.parse_argument()
            if self.test_lookahead(','):
                self.expect(',')
            else:
                break
        if self.test_lookahead('~', NAME, 'not', '-', NUMBER, '{', '(',
                               'lambda', '[', '`', '+', STRING):
            self.parse_argument()
            if self.test_lookahead(','):
                self.expect(',')
        elif self.test_lookahead('*'):
            self.expect('*')
            self.parse_test()
            if self.test_lookahead(','):
                self.expect(',')
                self.expect('**')
                self.parse_test()
        elif self.test_lookahead('**'):
            self.expect('**')
            self.parse_test()
        return self.pop()

    def parse_print_stmt (self):
        self.push('print_stmt')
        self.expect('print')
        if self.test_lookahead(">>"):
            self.expect(">>")
            self.parse_test()
            if self.test_lookahead(","):
                self.expect(",")
                self.parse_test()
                self._parse_test_list_tail()
        elif self.test_lookahead(*TEST_FIRST_SET):
            self.parse_test()
            self._parse_test_list_tail()
        return self.pop()

    def parse_listmaker (self):
        self.push('listmaker')
        self.parse_test()
        if self.test_lookahead('for'):
            self.parse_list_for()
        else:
            self._parse_test_list_tail()
        return self.pop()

    def parse_testlist (self):
        self.push('testlist')
        self.parse_test()
        self._parse_test_list_tail()
        return self.pop()

    def parse_testlist_gexp (self):
        self.push('testlist_gexp')
        self.parse_test()
        if self.test_lookahead('for'):
            self.parse_gen_for()
        elif not self.test_lookahead(')'):
            self._parse_test_list_tail()
        return self.pop()

    def _parse_test_list_tail (self):
        global TEST_FIRST_SET
        if self.test_lookahead(","):
            self.expect(",")
            while self.test_lookahead(*TEST_FIRST_SET):
                self.parse_test()
                if self.test_lookahead(','):
                    self.expect(',')

    def parse_dictmaker (self):
        global TEST_FIRST_SET
        self.push('dictmaker')
        self.parse_test()
        self.expect(':')
        self.parse_test()
        if self.test_lookahead(','):
            self.expect(',')        
            while self.test_lookahead(*TEST_FIRST_SET):
                self.parse_test()
                self.expect(':')
                self.parse_test()
                if self.test_lookahead(','):
                    self.expect(',')
        return self.pop()

    # ____________________________________________________________
    def parse_qsuite (self):
        """MyRealParser.parse_qsuite()
        """
        self.push('qsuite')
        # __________________________________________________
        # Grab everything until we get to the end.
        tokens = []
        indent_tok = None
        dedent_tok = None
        indent_size = 0
        crnt_token = self.tokenizer.next()
        if crnt_token[0] == NEWLINE:
            is_suite = True
            self.pushpop(crnt_token)
            crnt_token = self.tokenizer.next()
            while crnt_token[0] in (NEWLINE, NL, COMMENT):
                tokens.append(crnt_token)
                self.pushpop(crnt_token)
                crnt_token = self.tokenizer.next()
            if crnt_token[0] != INDENT:
                raise SyntaxError("Line %d: expected an indent (got %s)." %
                                  (crnt_token[2][0], str(crnt_token)))
            else:
                indent_tok = crnt_token
                indent_size = crnt_token[3][1]
                self.pushpop(crnt_token)
            level = 1
            while True:
                crnt_token = self.tokenizer.next()
                if crnt_token[0] == INDENT:
                    level += 1
                elif crnt_token[0] == DEDENT:
                    level -= 1
                    if level <= 0:
                        break
                tokens.append(crnt_token)
            dedent_tok = crnt_token
        else:
            is_suite = False
            while crnt_token[0] != NEWLINE:
                tokens.append(crnt_token)
                crnt_token = self.tokenizer.next()
            self.next_token = crnt_token
        # __________________________________________________
        # Now post process everything into a single token.
        lines = []
        for tok in tokens:
            if __DEBUG__:
                print tok
            # FIXME: Not sure this is the best way to handle comments
            # appearing before the dedents are detected (see line 20 of
            # test 02).
            if (tok[0] not in (COMMENT, DEDENT)) or (tok[2][1] >= indent_size):
                if tok[-1] not in lines:
                    lines.append(tok[-1])
        if __DEBUG__:
            print lines
        if is_suite:
            def process_line (ln):
                ret_val = ln[indent_size:]
                if not ret_val:
                    ret_val = "\n"
                return ret_val
            lines = [process_line(line) for line in lines]
        else:
            start_col = tokens[0][2][1]
            lines[0] = lines[0][start_col:]
        tok_str = "".join(lines)
        if __DEBUG__:
            print "_" * 60
            print tok_str
            print "_" * 60
        self.pushpop((QUOTED, tok_str, tokens[0][2], tokens[-1][3], None))
        if dedent_tok is not None:
            self.pushpop(dedent_tok)
        return self.pop()

# ______________________________________________________________________

if __name__ == "__main__":
    parser_main(MyRealParser)

# ______________________________________________________________________
# End of MyRealParser.py
